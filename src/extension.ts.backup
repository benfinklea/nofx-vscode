import * as vscode from 'vscode';
import { GracefulShutdown } from './services/reliability/GracefulShutdown';

console.log('[NofX Debug] Extension module loading...');

// Global services
let gracefulShutdown: GracefulShutdown;

// Core services
import { Container } from './services/Container';
import { OUTPUT_CHANNELS } from './constants/outputChannels';
import {
    SERVICE_TOKENS,
    IContainer,
    CONFIG_KEYS,
    ILoggingService,
    IEventBus,
    ITaskStateMachine,
    INotificationService,
    IConfigurationService,
    IErrorHandler,
    ICommandService,
    IPersistenceService,
    ValidationError
} from './services/interfaces';
import { EVENTS } from './services/EventConstants';
import { ConfigurationService } from './services/ConfigurationService';
// ConfigurationValidator removed - over-engineered
// MetricsService removed - unused
import { NotificationService } from './services/NotificationService';
import { LoggingService } from './services/LoggingService';
import { EventBus } from './services/EventBus';
import { ErrorHandler } from './services/ErrorHandler';
import { CommandService } from './services/CommandService';
import { TerminalManager } from './services/TerminalManager';
import { WorktreeService } from './services/WorktreeService';
// AutoWorktreeManager removed - redundant with WorktreeService
// AgentLifecycleManager removed - redundant with AgentManager

// Business logic
import { AgentManager } from './agents/AgentManager';
import { TaskQueue } from './tasks/TaskQueue';
import { TaskStateMachine } from './tasks/TaskStateMachine';
import { PriorityTaskQueue } from './tasks/PriorityTaskQueue';
import { CapabilityMatcher } from './tasks/CapabilityMatcher';
import { TaskDependencyManager } from './tasks/TaskDependencyManager';
import { priorityToNumeric } from './tasks/priority';
import { DirectCommunicationService } from './services/DirectCommunicationService';
// ConnectionPoolService removed - WebSocket overkill
// MessageRouter removed - overly complex, unused
// MessageValidator removed - over-engineered
// MessagePersistenceService removed - never actually persists
// InMemoryMessagePersistenceService removed - redundant
import { MessageFlowDashboard } from './dashboard/MessageFlowDashboard';
import { MessageType, OrchestratorMessage } from './orchestration/MessageProtocol';
import { AgentPersistence } from './persistence/AgentPersistence';
import { WorktreeManager } from './worktrees/WorktreeManager';
// TaskToolBridge removed - overly complex
// SessionPersistenceService removed - duplicate of AgentPersistence
import { PersistenceService } from './services/PersistenceService';

// Views
import { AgentTreeProvider } from './views/AgentTreeProvider';
import { TaskTreeProvider } from './views/TaskTreeProvider';
import { NofxDevTreeProvider } from './views/NofxDevTreeProvider';
import { NofxTerminalProvider } from './views/NofxTerminalProvider';
import { ModernNofXPanel } from './views/ModernNofXPanel';

// UI Services
import { UIStateManager } from './services/UIStateManager';
// TreeStateManager removed - UI state, move to views
import { ConductorViewModel } from './viewModels/ConductorViewModel';
import { DashboardViewModel } from './viewModels/DashboardViewModel';
import { TreeViewHost } from './ui/TreeViewHost';

// Command handlers
import { AgentCommands } from './commands/AgentCommands';
// TaskCommands removed - over-engineered
import { ConductorCommands } from './commands/ConductorCommands';
import { OrchestrationCommands } from './commands/OrchestrationCommands';
// PersistenceCommands removed - redundant session commands
// TemplateCommands removed - templates are JSON files
// WorktreeCommands removed - mostly unused git commands
import { UtilityCommands } from './commands/UtilityCommands';
// MetricsCommands removed - all metrics commands unused
// SessionCommands removed - redundant with auto-persistence

// Global container for dependency injection
let container: IContainer;

export async function activate(context: vscode.ExtensionContext) {
    const activationStartTime = Date.now();
    console.log('[NofX Debug] Extension activation started');

    try {
        // Basic telemetry using VS Code's built-in service
        console.log('[NofX Debug] Extension initializing with simplified telemetry');

        // Initialize graceful shutdown handler with enterprise reliability
        try {
            gracefulShutdown = new GracefulShutdown({
                maxShutdownTime: 30000, // 30 seconds
                forcefulShutdownDelay: 45000, // 45 seconds before forceful shutdown
                persistState: true,
                notifyUsers: true,
                onShutdownStart: () => {
                    console.log('[NofX] Graceful shutdown initiated...');
                },
                onShutdownComplete: () => {
                    console.log('[NofX] Graceful shutdown completed successfully');
                },
                onShutdownError: (error) => {
                    console.error('[NofX] Graceful shutdown error:', error);
                }
            });
            
            console.log('[NofX Debug] Graceful shutdown handler initialized');
        } catch (error) {
            console.error('[NofX Debug] Failed to initialize graceful shutdown:', error);
            // Continue without graceful shutdown - not critical for extension operation
        }

        // Initialize dependency injection container
        container = new Container();

        // Register core services
        container.registerInstance(SERVICE_TOKENS.ExtensionContext, context);

        const outputChannel = vscode.window.createOutputChannel(OUTPUT_CHANNELS.MAIN);
        container.registerInstance(SERVICE_TOKENS.OutputChannel, outputChannel);
        
        // Register enterprise telemetry service
        // Enterprise telemetry service removed - using VS Code built-in telemetry

        // Register LoggingService with enterprise telemetry integration
        container.register(
            SERVICE_TOKENS.LoggingService,
            container => {
                const loggingService = new LoggingService(
                    undefined, // ConfigurationService will be available later via resolveOptional
                    container.resolve(SERVICE_TOKENS.OutputChannel)
                );
                
                // Pass logging service to telemetry for enhanced error reporting
                try {
                    const telemetryService = container.resolve<EnterpriseTelemetryService>('EnterpriseTelemetryService');
                    (telemetryService as any).loggingService = loggingService;
                } catch (error) {
                    console.warn('[NofX Debug] Could not link logging service to telemetry:', error);
                }
                
                return loggingService;
            },
            'singleton'
        );

        // Register foundational services (in dependency order)
        container.register(
            SERVICE_TOKENS.EventBus,
            container => {
                console.log('[NofX Debug] Creating EventBus...');
                try {
                    const loggingService = container.resolveOptional<ILoggingService>(SERVICE_TOKENS.LoggingService);
                    console.log('[NofX Debug] LoggingService resolved for EventBus (optional):', !!loggingService);

                    const eventBus = new EventBus(loggingService);
                    console.log('[NofX Debug] EventBus created successfully');
                    return eventBus;
                } catch (error) {
                    console.error('[NofX Debug] Failed to create EventBus:', error);
                    throw error;
                }
            },
            'singleton'
        );
        container.register(
            SERVICE_TOKENS.NotificationService,
            () => {
                console.log('[NofX Debug] Creating NotificationService...');
                try {
                    const notificationService = new NotificationService();
                    console.log('[NofX Debug] NotificationService created successfully');
                    return notificationService;
                } catch (error) {
                    console.error('[NofX Debug] Failed to create NotificationService:', error);
                    throw error;
                }
            },
            'singleton'
        );

        // Register configuration service (simplified - no validator needed)
        container.register(
            SERVICE_TOKENS.ConfigurationService,
            container => {
                try {
                    console.log('[NofX Debug] Creating ConfigurationService...');
                    const eventBus = container.resolve<IEventBus>(SERVICE_TOKENS.EventBus);
                    console.log('[NofX Debug] EventBus resolved for ConfigurationService');
                    const configService = new ConfigurationService(context, eventBus);
                    console.log('[NofX Debug] ConfigurationService created successfully');
                    return configService;
                } catch (error) {
                    console.error('[NofX Debug] Failed to create ConfigurationService:', error);
                    // Try to create basic service
                    try {
                        return new ConfigurationService(context);
                    } catch (fallbackError) {
                        console.error('[NofX Debug] Fallback ConfigurationService creation failed:', fallbackError);
                        throw error;
                    }
                }
            },
            'singleton'
        );

        // Now connect LoggingService to ConfigurationService
        try {
            const loggingSvc = container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService) as any;
            const configSvc = container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService);
            if (loggingSvc && typeof loggingSvc.setConfigurationService === 'function') {
                loggingSvc.setConfigurationService(configSvc);
            }
        } catch (error) {
            console.error('[NofX Debug] Failed to connect LoggingService to ConfigurationService:', error);
            // Continue without configuration-aware logging
        }

        container.register(
            SERVICE_TOKENS.ErrorHandler,
            container =>
                new ErrorHandler(
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService)
                ),
            'singleton'
        );

        container.register(
            SERVICE_TOKENS.CommandService,
            container =>
                new CommandService(
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<IErrorHandler>(SERVICE_TOKENS.ErrorHandler)
                ),
            'singleton'
        );

        // Register AgentNotificationService for agent-specific and system-wide notifications
        container.register(
            SERVICE_TOKENS.AgentNotificationService,
            container => {
                const AgentNotificationService =
                    require('./services/AgentNotificationService').AgentNotificationService;
                return new AgentNotificationService(
                    container.resolve<vscode.ExtensionContext>(SERVICE_TOKENS.ExtensionContext),
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService)
                );
            },
            'singleton'
        );

        // Get logging service for use in activation
        const loggingService = container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService);
        const errorHandler = container.resolve<IErrorHandler>(SERVICE_TOKENS.ErrorHandler);

        // Set logging service on container for future operations
        container.setLoggingService(loggingService);

        // Set logging service on EventBus to enable debug event logging
        const eventBus = container.resolve<IEventBus>(SERVICE_TOKENS.EventBus);
        eventBus.setLoggingService(loggingService);

        loggingService.info('🎸 n of x Multi-Agent Orchestrator is now active!');

        // Get workspace folder once
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];

        // Register WorktreeManager and AgentPersistence BEFORE WorktreeService
        if (workspaceFolder) {
            const worktreeManager = new WorktreeManager(
                workspaceFolder.uri.fsPath,
                loggingService,
                container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService)
            );
            container.registerInstance(SERVICE_TOKENS.WorktreeManager, worktreeManager);

            // Register AgentPersistence
            const agentPersistence = new AgentPersistence(workspaceFolder.uri.fsPath, loggingService);
            container.registerInstance(SERVICE_TOKENS.AgentPersistence, agentPersistence);

            // Register SessionPersistenceService (deprecated - will be removed)
            const sessionPersistenceService = new SessionPersistenceService(
                context,
                container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                container.resolve<IEventBus>(SERVICE_TOKENS.EventBus)
            );
            container.registerInstance(SERVICE_TOKENS.SessionPersistenceService, sessionPersistenceService);

            // Register new unified PersistenceService
            const persistenceService = new PersistenceService(
                context,
                container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                container.resolve<IEventBus>(SERVICE_TOKENS.EventBus)
            );
            container.registerInstance(SERVICE_TOKENS.PersistenceService, persistenceService);
        }

        // Register new services
        container.register(
            SERVICE_TOKENS.TerminalManager,
            container =>
                new TerminalManager(
                    container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService),
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
                    container.resolve<IErrorHandler>(SERVICE_TOKENS.ErrorHandler)
                ),
            'singleton'
        );
        container.register(
            SERVICE_TOKENS.WorktreeService,
            container =>
                new WorktreeService(
                    container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService),
                    container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService),
                    container.resolve(SERVICE_TOKENS.WorktreeManager),
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<IErrorHandler>(SERVICE_TOKENS.ErrorHandler)
                ),
            'singleton'
        );

        // Register business services
        const agentManager = new AgentManager(context, container.resolveOptional(SERVICE_TOKENS.AgentPersistence));
        container.registerInstance(SERVICE_TOKENS.AgentManager, agentManager);

        // Register AgentLifecycleManager with callback to AgentManager
        container.register(
            SERVICE_TOKENS.AgentLifecycleManager,
            container =>
                new AgentLifecycleManager(
                    container.resolve(SERVICE_TOKENS.TerminalManager),
                    container.resolve(SERVICE_TOKENS.WorktreeService),
                    container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService),
                    container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService),
                    () => {
                        // Callback for agent updates
                        agentManager.notifyAgentUpdated();
                    },
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
                    container.resolve<IErrorHandler>(SERVICE_TOKENS.ErrorHandler)
                ),
            'singleton'
        );

        // Set the dependencies in AgentManager after registration
        agentManager.setDependencies(
            container.resolve(SERVICE_TOKENS.AgentLifecycleManager),
            container.resolve(SERVICE_TOKENS.TerminalManager),
            container.resolve(SERVICE_TOKENS.WorktreeService),
            container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService),
            container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService),
            container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
            container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
            container.resolve<IErrorHandler>(SERVICE_TOKENS.ErrorHandler),
            container.resolveOptional<ISessionPersistenceService>(SERVICE_TOKENS.SessionPersistenceService)
        );

        // Register shutdown handlers for enterprise reliability
        if (gracefulShutdown) {
            // Register agent manager shutdown handler
            gracefulShutdown.registerHandler({
                name: 'agent-manager',
                priority: 1,
                timeout: 15000, // 15 seconds for agent cleanup
                handler: async () => {
                    loggingService.info('[GracefulShutdown] Disposing AgentManager...');
                    await agentManager.dispose();
                }
            });

            // Register telemetry shutdown handler
            gracefulShutdown.registerHandler({
                name: 'telemetry-service',
                priority: 5,
                timeout: 5000, // 5 seconds for telemetry
                handler: async () => {
                    loggingService.info('[GracefulShutdown] Shutting down telemetry...');
                    // Telemetry cleanup - using VS Code built-in service
                }
            });

            // Register container shutdown handler
            gracefulShutdown.registerHandler({
                name: 'dependency-container',
                priority: 10,
                timeout: 10000, // 10 seconds for container disposal
                handler: async () => {
                    loggingService.info('[GracefulShutdown] Disposing dependency container...');
                    if (container) {
                        await container.dispose();
                    }
                }
            });

            loggingService.info('[GracefulShutdown] Registered shutdown handlers for enterprise components');
        }

        // Register AutoWorktreeManager for automatic worktree management
        container.register(
            SERVICE_TOKENS.AutoWorktreeManager,
            container =>
                new AutoWorktreeManager(
                    container.resolve(SERVICE_TOKENS.AgentManager),
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService),
                    container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService),
                    container.resolveOptional<IEventBus>(SERVICE_TOKENS.EventBus)
                ),
            'singleton'
        );

        // Register new task management services
        container.register(
            SERVICE_TOKENS.TaskStateMachine,
            container =>
                new TaskStateMachine(
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
                    container.resolveOptional(SERVICE_TOKENS.TaskQueue) // Optional to avoid circular dependency during initial registration
                ),
            'singleton'
        );

        // Register TaskDependencyManager BEFORE PriorityTaskQueue to ensure it's available
        container.register(
            SERVICE_TOKENS.TaskDependencyManager,
            container =>
                new TaskDependencyManager(
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
                    container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService)
                ),
            'singleton'
        );

        container.register(
            SERVICE_TOKENS.PriorityTaskQueue,
            container =>
                new PriorityTaskQueue(
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve(SERVICE_TOKENS.TaskDependencyManager)
                ),
            'singleton'
        );

        container.register(
            SERVICE_TOKENS.CapabilityMatcher,
            container =>
                new CapabilityMatcher(
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService)
                ),
            'singleton'
        );

        // Register sub-agent services
        container.register(
            SERVICE_TOKENS.TaskToolBridge,
            container =>
                new (require('./services/TaskToolBridge').TaskToolBridge)(
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService)
                ),
            'singleton'
        );

        container.register(
            SERVICE_TOKENS.TerminalMonitor,
            container =>
                new (require('./services/TerminalMonitor').TerminalMonitor)(
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService),
                    container.resolve(SERVICE_TOKENS.TaskToolBridge)
                ),
            'singleton'
        );

        const taskQueue = new TaskQueue(
            agentManager,
            container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
            container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
            container.resolve<IErrorHandler>(SERVICE_TOKENS.ErrorHandler),
            container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService),
            container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService),
            container.resolve(SERVICE_TOKENS.TaskStateMachine),
            container.resolve(SERVICE_TOKENS.PriorityTaskQueue),
            container.resolve(SERVICE_TOKENS.CapabilityMatcher),
            container.resolve(SERVICE_TOKENS.TaskDependencyManager)
        );
        container.registerInstance(SERVICE_TOKENS.TaskQueue, taskQueue);

        // Inject TaskQueue into TaskStateMachine for dependency validation
        const taskStateMachine = container.resolve<ITaskStateMachine>(SERVICE_TOKENS.TaskStateMachine);
        taskStateMachine.setTaskReader(taskQueue);

        // Check if we're in test mode to skip auto behaviors and noisy services
        const config = container.resolve<ConfigurationService>(SERVICE_TOKENS.ConfigurationService);
        const isTestMode = config.get(CONFIG_KEYS.TEST_MODE, false);
        console.log('[NofX Debug] Test mode:', isTestMode);

        if (isTestMode) {
            loggingService.info('🧪 Test mode enabled - skipping auto behaviors and noisy services');

            // Optionally disable metrics in test mode
            await config.update(CONFIG_KEYS.ENABLE_METRICS, false, vscode.ConfigurationTarget.Global);
        }

        // Initialize agent manager (this will check for saved agents)
        await agentManager.initialize();

        // Migrate existing tasks to normalize new fields
        await migrateExistingTasks(taskQueue, loggingService);

        // Set initial context for UI
        const commandService = container.resolve<ICommandService>(SERVICE_TOKENS.CommandService);
        await commandService.execute('setContext', 'nofx.hasAgents', agentManager.getActiveAgents().length > 0);

        // Register orchestration services
        container.register(
            SERVICE_TOKENS.ConnectionPoolService,
            container =>
                new ConnectionPoolService(
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
                    container.resolve<IErrorHandler>(SERVICE_TOKENS.ErrorHandler),
                    container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService)
                ),
            'singleton'
        );

        container.register(
            SERVICE_TOKENS.MessageValidator,
            container =>
                new MessageValidator(
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<IEventBus>(SERVICE_TOKENS.EventBus)
                ),
            'singleton'
        );

        // Register MessagePersistenceService with workspace path or use in-memory fallback
        let messagePersistence: IMessagePersistenceService;

        if (workspaceFolder) {
            messagePersistence = new MessagePersistenceService(
                container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService),
                container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
                workspaceFolder.uri.fsPath
            );
        } else {
            messagePersistence = new InMemoryMessagePersistenceService(
                container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService),
                container.resolve<IEventBus>(SERVICE_TOKENS.EventBus)
            );
        }

        container.registerInstance(SERVICE_TOKENS.MessagePersistenceService, messagePersistence);

        container.register(
            SERVICE_TOKENS.MessageRouter,
            container =>
                new MessageRouter(
                    container.resolve(SERVICE_TOKENS.ConnectionPoolService),
                    container.resolve(SERVICE_TOKENS.MessagePersistenceService),
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
                    container.resolve<IErrorHandler>(SERVICE_TOKENS.ErrorHandler),
                    container.resolve(SERVICE_TOKENS.AgentManager),
                    container.resolve(SERVICE_TOKENS.TaskQueue),
                    container.resolveOptional(SERVICE_TOKENS.TaskToolBridge)
                ),
            'singleton'
        );

        // Start DirectCommunicationService with new services (skip in test mode)
        let directCommunicationService: DirectCommunicationService | undefined;
        if (!isTestMode) {
            console.log('[NofX Debug] Creating DirectCommunicationService (not in test mode)');
            directCommunicationService = new DirectCommunicationService(
                container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
                container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService)
            );

            // Start DirectCommunicationService with error handling
            try {
                console.log('[NofX Debug] Starting DirectCommunicationService...');
                await directCommunicationService.start();
                console.log('[NofX Debug] DirectCommunicationService started successfully');
            } catch (error: any) {
                console.error('[NofX Debug] Failed to start DirectCommunicationService:', error);
                const notificationService = container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService);
                loggingService.error('Failed to start DirectCommunicationService', error);

                notificationService.showWarning(
                    `NofX DirectCommunicationService could not start: ${error.message}. Some features may be unavailable.`
                );

                // Continue activation without failing - other features can still work
                directCommunicationService = undefined;
            }

            if (directCommunicationService) {
                container.registerInstance(SERVICE_TOKENS.OrchestrationServer, directCommunicationService);
            } else {
                // Register a mock service if the real one failed to start
                const mockDirectCommunicationService = {
                    start: () => Promise.resolve(),
                    stop: () => Promise.resolve(),
                    generateTestMessages: () => {},
                    getMetrics: () => ({ totalMessages: 0, isStarted: false }),
                    setDashboardCallback: () => {},
                    dispose: () => {}
                };
                container.registerInstance(SERVICE_TOKENS.OrchestrationServer, mockDirectCommunicationService);
            }
        } else {
            console.log('[NofX Debug] Skipping DirectCommunicationService (test mode enabled)');
            // Register a mock service for test mode
            const mockDirectCommunicationService = {
                start: () => Promise.resolve(),
                stop: () => Promise.resolve(),
                generateTestMessages: () => {},
                getMetrics: () => ({ totalMessages: 0, isStarted: false }),
                setDashboardCallback: () => {},
                dispose: () => {}
            };
            container.registerInstance(SERVICE_TOKENS.OrchestrationServer, mockDirectCommunicationService);
        }

        // Register UI services
        container.register(
            SERVICE_TOKENS.UIStateManager,
            container =>
                new UIStateManager(
                    container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve(SERVICE_TOKENS.AgentManager), // Now implements IAgentReader
                    container.resolve(SERVICE_TOKENS.TaskQueue) // Now implements ITaskReader
                ),
            'singleton'
        );

        container.register(
            SERVICE_TOKENS.TreeStateManager,
            container =>
                new TreeStateManager(
                    container.resolve(SERVICE_TOKENS.UIStateManager),
                    container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService)
                ),
            'singleton'
        );

        container.register(
            SERVICE_TOKENS.ConductorViewModel,
            container =>
                new ConductorViewModel(
                    container.resolve(SERVICE_TOKENS.UIStateManager),
                    container.resolve<ICommandService>(SERVICE_TOKENS.CommandService),
                    container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService)
                ),
            'singleton'
        );

        container.register(
            SERVICE_TOKENS.DashboardViewModel,
            container =>
                new DashboardViewModel(
                    container.resolve(SERVICE_TOKENS.UIStateManager),
                    container.resolve(SERVICE_TOKENS.OrchestrationServer),
                    container.resolve<IEventBus>(SERVICE_TOKENS.EventBus),
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService),
                    container.resolve(SERVICE_TOKENS.MessagePersistenceService),
                    container.resolve(SERVICE_TOKENS.ConnectionPoolService)
                ),
            'singleton'
        );

        // Register message flow dashboard factory for on-demand creation
        // Dashboard will be created via 'nofx.openMessageFlow' command when needed
        container.register(
            SERVICE_TOKENS.MessageFlowDashboard,
            container =>
                MessageFlowDashboard.create(
                    context,
                    container.resolve(SERVICE_TOKENS.DashboardViewModel),
                    container.resolve<ILoggingService>(SERVICE_TOKENS.LoggingService)
                ),
            'transient'
        );

        // Message handling is now done through MessageRouter

        // Register tree data providers for sidebar views
        const nofxDevProvider = new NofxDevTreeProvider();
        const agentProvider = new AgentTreeProvider(
            container.resolve<ITreeStateManager>(SERVICE_TOKENS.TreeStateManager),
            container.resolve(SERVICE_TOKENS.UIStateManager),
            container.resolveOptional<TaskToolBridge>(SERVICE_TOKENS.TaskToolBridge)
        );
        const taskProvider = new TaskTreeProvider(container.resolve(SERVICE_TOKENS.UIStateManager), container);

        vscode.window.registerTreeDataProvider('nofx.dev', nofxDevProvider);
        vscode.window.registerTreeDataProvider('nofx.activity', agentProvider);

        // Register task tree with drag and drop support
        const taskTreeView = vscode.window.createTreeView('nofx.tasks', {
            treeDataProvider: taskProvider,
            dragAndDropController: taskProvider.getDragAndDropController(),
            showCollapseAll: true
        });
        context.subscriptions.push(taskTreeView);

        const agentTreeView = vscode.window.createTreeView('nofx.agents', {
            treeDataProvider: agentProvider,
            showCollapseAll: true
        });

        // Create TreeViewHost for the agents tree view
        const agentTreeViewHost = TreeViewHost.create(agentTreeView, agentProvider, loggingService);
        container.registerInstance(SERVICE_TOKENS.AgentTreeViewHost, agentTreeViewHost);

        // Hook into expand/collapse events to update TreeStateManager
        const treeStateManager = container.resolve<ITreeStateManager>(SERVICE_TOKENS.TreeStateManager);
        context.subscriptions.push(
            agentTreeView.onDidExpandElement(e => {
                const element = e.element;
                if (element && element.contextValue === 'teamSection') {
                    treeStateManager.toggleSection('teamSection');
                }
            }),
            agentTreeView.onDidCollapseElement(e => {
                const element = e.element;
                if (element && element.contextValue === 'teamSection') {
                    treeStateManager.toggleSection('teamSection');
                }
            })
        );

        context.subscriptions.push(agentTreeView);

        // Register modern NofX control panel
        const modernPanelProvider = new ModernNofXPanel(container);
        context.subscriptions.push(
            vscode.window.registerWebviewViewProvider(ModernNofXPanel.viewType, modernPanelProvider, {
                webviewOptions: {
                    retainContextWhenHidden: true
                }
            })
        );

        // Register NofX terminal panel provider
        const terminalProvider = new NofxTerminalProvider(context.extensionUri, agentManager);
        context.subscriptions.push(
            vscode.window.registerWebviewViewProvider(NofxTerminalProvider.viewType, terminalProvider, {
                webviewOptions: {
                    retainContextWhenHidden: true
                }
            })
        );

        // Update context when agents change
        agentManager.onAgentUpdate(() => {
            const hasAgents = agentManager.getActiveAgents().length > 0;
            commandService.execute('setContext', 'nofx.hasAgents', hasAgents);
        });

        // Register command handlers
        const agentCommands = new AgentCommands(container);
        agentCommands.register();
        context.subscriptions.push({ dispose: () => agentCommands.dispose() });

        const taskCommands = new TaskCommands(container);
        taskCommands.register();
        context.subscriptions.push({ dispose: () => taskCommands.dispose() });

        const conductorCommands = new ConductorCommands(container);
        conductorCommands.setAgentProvider(agentProvider);
        conductorCommands.register();
        context.subscriptions.push({ dispose: () => conductorCommands.dispose() });

        const orchestrationCommands = new OrchestrationCommands(container);
        if (directCommunicationService) {
            orchestrationCommands.setOrchestrationServer(directCommunicationService);
        }
        orchestrationCommands.register();
        context.subscriptions.push({ dispose: () => orchestrationCommands.dispose() });

        const persistenceCommands = new PersistenceCommands(container);
        persistenceCommands.register();
        context.subscriptions.push({ dispose: () => persistenceCommands.dispose() });

        const templateCommands = new TemplateCommands(container);
        templateCommands.register();
        context.subscriptions.push({ dispose: () => templateCommands.dispose() });

        const worktreeCommands = new WorktreeCommands(container);
        worktreeCommands.register();
        context.subscriptions.push({ dispose: () => worktreeCommands.dispose() });

        const utilityCommands = new UtilityCommands(container);
        utilityCommands.register();
        context.subscriptions.push({ dispose: () => utilityCommands.dispose() });


        // Register session commands
        const sessionCommands = new SessionCommands(container);
        if (workspaceFolder && container.resolveOptional(SERVICE_TOKENS.SessionPersistenceService)) {
            sessionCommands.setSessionService(container.resolve(SERVICE_TOKENS.SessionPersistenceService));
        }
        sessionCommands.register();
        context.subscriptions.push({ dispose: () => sessionCommands.dispose() });

        // Add a simple test command to verify command registration works
        const testCommand = vscode.commands.registerCommand('nofx.testCommand', () => {
            console.log('[NofX Debug] Test command executed!');
            vscode.window.showInformationMessage('NofX Test Command Works! 🎉');
        });
        context.subscriptions.push(testCommand);

        // Log all registered commands for debugging
        console.log('[NofX Debug] Extension activated, registered commands:', commandService.getRegisteredCommands());

        // Status Bar Item (skip in test mode to reduce noise)
        let statusBarItem: vscode.StatusBarItem | undefined;
        let updateStatusBar: (() => void) | undefined;

        if (!isTestMode) {
            statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
            statusBarItem.text = '$(organization) NofX';
            statusBarItem.tooltip = 'Multi-Agent Orchestrator';
            statusBarItem.command = 'nofx.showOrchestrator';
            statusBarItem.show();
            context.subscriptions.push(statusBarItem);
            container.registerInstance(SERVICE_TOKENS.StatusBarItem, statusBarItem);

            // Update status bar with task statistics
            updateStatusBar = () => {
                const taskStats = taskQueue.getTaskStats();
                const agentStats = agentManager.getAgentStats();

                let statusText = '$(organization) NofX';
                if (taskStats.total > 0) {
                    statusText += ` | 📋 ${taskStats.ready} ready, ${taskStats.inProgress} active`;
                    if (taskStats.blocked > 0) {
                        statusText += `, 🔴 ${taskStats.blocked} blocked`;
                    }
                }
                if (agentStats.total > 0) {
                    statusText += ` | 🤖 ${agentStats.idle} idle, ${agentStats.working} working`;
                }

                statusBarItem!.text = statusText;
            };

            // Subscribe to task and agent updates
            const eventBus = container.resolve<IEventBus>(SERVICE_TOKENS.EventBus) as IEventBus;
            const eventSubscriptions = [
                eventBus.subscribe(EVENTS.TASK_CREATED, updateStatusBar),
                eventBus.subscribe(EVENTS.TASK_COMPLETED, updateStatusBar),
                eventBus.subscribe(EVENTS.TASK_ASSIGNED, updateStatusBar),
                eventBus.subscribe(EVENTS.TASK_BLOCKED, updateStatusBar),
                eventBus.subscribe(EVENTS.TASK_READY, updateStatusBar),
                eventBus.subscribe(EVENTS.AGENT_CREATED, updateStatusBar),
                eventBus.subscribe(EVENTS.AGENT_REMOVED, updateStatusBar),
                eventBus.subscribe(EVENTS.AGENT_STATUS_CHANGED, updateStatusBar)
            ];

            // Add all event subscriptions to context for disposal
            context.subscriptions.push(...eventSubscriptions);

            // Initial update
            updateStatusBar();
        } else {
            // Register a mock status bar item for test mode
            const mockStatusBarItem = {
                text: '',
                tooltip: '',
                command: '',
                show: () => {},
                hide: () => {},
                dispose: () => {}
            };
            container.registerInstance(SERVICE_TOKENS.StatusBarItem, mockStatusBarItem);
        }

        // Auto-start if configured (skip in test mode)
        if (!isTestMode && config.get(CONFIG_KEYS.AUTO_START, false)) {
            await commandService.execute('nofx.quickStartChat');
        }


        // Validate configuration during startup (includes both schema and cross-field validation)
        const configService = container.resolve<IConfigurationService>(SERVICE_TOKENS.ConfigurationService);
        const validationResult = configService.validateAll();
        if (!validationResult.isValid) {
            const errorMessages = validationResult.errors
                .map((e: ValidationError) => `${e.field}: ${e.message}`)
                .join('; ');
            loggingService.warn('Configuration validation issues detected', { errors: validationResult.errors });

            // Show notification for critical errors
            const criticalErrors = validationResult.errors.filter((e: ValidationError) => e.severity === 'error');
            if (criticalErrors.length > 0) {
                const notificationService = container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService);
                await notificationService.showWarning(
                    `Configuration validation failed: ${errorMessages}. Some features may not work correctly.`
                );
            }

            // Show notification for warnings
            const warnings = validationResult.errors.filter((e: ValidationError) => e.severity === 'warning');
            if (warnings.length > 0) {
                const warningMessages = warnings.map((e: ValidationError) => `${e.field}: ${e.message}`).join('; ');
                const notificationService = container.resolve<INotificationService>(SERVICE_TOKENS.NotificationService);
                await notificationService.showWarning(`Configuration warnings: ${warningMessages}`);
            }
        }


        // Send telemetry for extension activation with enterprise reliability
        try {
            console.log('[NofX Debug] Extension activated successfully', {
                'services.registered': '19', // Updated service count
                'agents.active': String(agentManager.getActiveAgents().length),
                'tasks.total': String(taskQueue.getTasks().length),
                'initialization.duration': String(Date.now() - activationStartTime)
            }, {
                'startup.latency': Date.now() - activationStartTime,
                'queue.size': taskQueue.getTasks().length,
                'agents.count': agentManager.getActiveAgents().length
            });
        } catch (error) {
            // Telemetry errors should never break extension functionality
            loggingService.warn('Failed to send activation telemetry', error);
        }

        loggingService.info('🎸 NofX Multi-Agent Orchestrator activation completed with VS Code telemetry');

        console.log('[NofX Debug] Extension fully activated');
        console.log('[NofX Debug] Registered commands:', commandService.getRegisteredCommands());

        // Note: Global context removed - use dependency injection instead
    } catch (error) {
        console.error('[NofX Debug] Extension activation failed:', error);
        vscode.window.showErrorMessage(`NofX Extension failed to activate: ${error}`);
        throw error;
    }
}

/**
 * Get container for tests only
 * This is guarded by NODE_ENV to prevent accidental usage in production
 */
export function __getContainerForTests(): IContainer | undefined {
    if (process.env.NODE_ENV === 'test') {
        return container;
    }
    return undefined;
}

/**
 * Migrates existing tasks to normalize new fields
 */
async function migrateExistingTasks(taskQueue: TaskQueue, loggingService: ILoggingService): Promise<void> {
    try {
        const allTasks = taskQueue.getTasks();
        let migratedCount = 0;

        for (const task of allTasks) {
            let needsUpdate = false;

            // Ensure numericPriority is set
            if (task.numericPriority === undefined) {
                task.numericPriority = priorityToNumeric(task.priority);
                needsUpdate = true;
            }

            // Ensure conflictsWith is initialized
            if (task.conflictsWith === undefined) {
                task.conflictsWith = [];
                needsUpdate = true;
            }

            // Ensure blockedBy is initialized
            if (task.blockedBy === undefined) {
                task.blockedBy = [];
                needsUpdate = true;
            }

            // Ensure dependsOn is initialized
            if (task.dependsOn === undefined) {
                task.dependsOn = [];
                needsUpdate = true;
            }

            // Ensure tags is initialized
            if (task.tags === undefined) {
                task.tags = [];
                needsUpdate = true;
            }

            // Ensure requiredCapabilities is initialized
            if (task.requiredCapabilities === undefined) {
                task.requiredCapabilities = [];
                needsUpdate = true;
            }

            if (needsUpdate) {
                migratedCount++;
                loggingService.debug(`Migrated task ${task.id} with new fields`);
            }
        }

        if (migratedCount > 0) {
            loggingService.info(`Migrated ${migratedCount} existing tasks with new field defaults`);
        }
    } catch (error) {
        loggingService.error('Error during task migration:', error);
    }
}

export async function deactivate(): Promise<void> {
    console.log('[NofX Debug] Extension deactivation initiated');
    
    // Get logging service for deactivation logging
    const loggingService = container?.resolveOptional<ILoggingService>(SERVICE_TOKENS.LoggingService);
    if (loggingService) {
        loggingService.info('NofX extension deactivating with enterprise reliability...');
    }

    // Use graceful shutdown if available
    if (gracefulShutdown) {
        try {
            // Simple deactivation logging
            console.log('[NofX Debug] Extension deactivation started');
            
            // Execute graceful shutdown
            await gracefulShutdown.shutdown('Extension deactivation');
            console.log('[NofX Debug] Graceful shutdown completed successfully');
            return;
            
        } catch (error) {
            console.error('[NofX Debug] Graceful shutdown failed, falling back to manual cleanup:', error);
            // Fall through to manual cleanup
        }
    }

    // Manual cleanup fallback (if graceful shutdown is not available or fails)
    console.log('[NofX Debug] Performing manual cleanup...');

    // Simple cleanup without enterprise telemetry
    try {
        console.log('[NofX Debug] Manual cleanup - extension deactivated');
    } catch (error) {
        console.warn('[NofX Debug] Error during cleanup:', error);
    }

    // Stop DirectCommunicationService and services
    const directCommunicationService = container?.resolveOptional<DirectCommunicationService>(SERVICE_TOKENS.OrchestrationServer);
    if (directCommunicationService) {
        await directCommunicationService.stop();
    }

    // Dispose orchestration services
    const connectionPool = container?.resolveOptional(SERVICE_TOKENS.ConnectionPoolService);
    if (
        connectionPool &&
        typeof connectionPool === 'object' &&
        connectionPool !== null &&
        'dispose' in connectionPool
    ) {
        (connectionPool as any).dispose();
    }

    const messageRouter = container?.resolveOptional(SERVICE_TOKENS.MessageRouter);
    if (messageRouter && typeof messageRouter === 'object' && messageRouter !== null && 'dispose' in messageRouter) {
        (messageRouter as any).dispose();
    }

    const messageValidator = container?.resolveOptional(SERVICE_TOKENS.MessageValidator);
    if (
        messageValidator &&
        typeof messageValidator === 'object' &&
        messageValidator !== null &&
        'dispose' in messageValidator
    ) {
        (messageValidator as any).dispose();
    }

    const messagePersistence = container?.resolveOptional(SERVICE_TOKENS.MessagePersistenceService);
    if (
        messagePersistence &&
        typeof messagePersistence === 'object' &&
        messagePersistence !== null &&
        'dispose' in messagePersistence
    ) {
        (messagePersistence as any).dispose();
    }

    // Dispose any active MessageFlowDashboard instances
    const messageFlowDashboard = container?.resolveOptional(SERVICE_TOKENS.MessageFlowDashboard);
    if (
        messageFlowDashboard &&
        typeof messageFlowDashboard === 'object' &&
        messageFlowDashboard !== null &&
        'dispose' in messageFlowDashboard
    ) {
        (messageFlowDashboard as any).dispose();
    }

    // Log deactivation before disposing container
    if (loggingService) {
        loggingService.info('NofX extension deactivated');
    }

    // Dispose container and all services
    if (container) {
        // Get agent manager and dispose it properly
        const agentManager = container?.resolveOptional(SERVICE_TOKENS.AgentManager);
        if (agentManager && typeof agentManager === 'object' && agentManager !== null && 'dispose' in agentManager) {
            await (agentManager as any).dispose();
        }

        await container.dispose();
    }
}
